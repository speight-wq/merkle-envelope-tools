<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src https://api.whatsonchain.com; img-src 'self' data:; form-action 'none';">
  <title>Envelope Generator — Merkle Envelope Tools</title>
  <script src="lib/crypto.js"></script>
  <script src="lib/encoding.js"></script>
  <script src="lib/headers.js"></script>
  <style>
    :root { --bg: #fff; --surface: #f8f9fa; --border: #dee2e6; --text: #212529; --text-2: #495057; --text-3: #868e96; --accent: #228be6; --success: #2f9e44; --success-bg: #d3f9d8; --warning: #e67700; --warning-bg: #fff3bf; --danger: #e03131; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); line-height: 1.6; padding: 32px 24px; max-width: 720px; margin: 0 auto; }
    h1 { font-size: 1.75rem; font-weight: 600; margin-bottom: 8px; }
    .subtitle { color: var(--text-2); margin-bottom: 24px; }
    .subtitle a { color: var(--accent); text-decoration: none; }
    .notice { background: var(--warning-bg); border: 2px solid var(--warning); border-radius: 8px; padding: 16px 20px; margin-bottom: 24px; }
    .notice-title { font-weight: 600; margin-bottom: 4px; }
    .notice-text { color: var(--text-2); font-size: 0.95rem; }
    .section { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 24px; margin-bottom: 24px; }
    .section-title { font-size: 1rem; font-weight: 600; margin-bottom: 16px; }
    .field { margin-bottom: 16px; }
    .label { display: block; font-size: 0.875rem; font-weight: 500; color: var(--text-2); margin-bottom: 6px; }
    .input { width: 100%; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-family: monospace; font-size: 0.875rem; }
    .input:focus { outline: none; border-color: var(--accent); }
    textarea.input { min-height: 100px; resize: vertical; }
    .hint { font-size: 0.8rem; color: var(--text-3); margin-top: 4px; }
    .btn { display: inline-block; padding: 12px 24px; border-radius: 6px; font-size: 0.875rem; font-weight: 500; cursor: pointer; border: none; }
    .btn-primary { background: var(--accent); color: white; }
    .btn-secondary { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-row { display: flex; gap: 8px; margin-top: 16px; flex-wrap: wrap; }
    .hidden { display: none !important; }
    .divider { height: 1px; background: var(--border); margin: 16px 0; }
    .tabs { display: flex; gap: 4px; background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 4px; margin-bottom: 20px; }
    .tab { flex: 1; padding: 10px 16px; background: transparent; border: none; border-radius: 6px; color: var(--text-2); font-size: 0.875rem; font-weight: 500; cursor: pointer; text-align: center; }
    .tab.active { background: var(--accent); color: white; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .progress-bar { height: 8px; background: var(--border); border-radius: 4px; overflow: hidden; margin-bottom: 8px; }
    .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }
    .progress-text { font-size: 0.85rem; color: var(--text-2); }
    .result-box { border-radius: 8px; padding: 20px; margin-top: 20px; }
    .result-box.success { background: var(--success-bg); border: 2px solid var(--success); }
    .result-title { font-weight: 600; margin-bottom: 12px; color: var(--success); }
    .info-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 0.875rem; }
    .info-row:last-child { border-bottom: none; }
    .info-label { color: var(--text-3); }
    .info-value { font-family: monospace; font-size: 0.85rem; }
    .envelope-item { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 8px; }
    .envelope-header { display: flex; justify-content: space-between; align-items: center; }
    .envelope-txid { font-family: monospace; font-size: 0.85rem; color: var(--accent); }
    .envelope-amount { font-weight: 500; }
    .error-box { background: #ffe3e3; border: 2px solid var(--danger); border-radius: 8px; padding: 16px; color: var(--danger); margin-top: 16px; }
    .input-narrow { width: 100px; }
    .trust-summary { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-top: 16px; }
    .trust-header { font-weight: 600; margin-bottom: 12px; font-size: 0.9rem; }
    .trust-sources { display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 12px; }
    .source-status { display: flex; align-items: center; gap: 4px; font-size: 0.85rem; }
    .source-ok { color: var(--success); }
    .source-fail { color: var(--danger); }
    .source-warn { color: var(--warning); }
    .trust-checks { display: flex; gap: 16px; flex-wrap: wrap; font-size: 0.85rem; margin-top: 8px; }
    .trust-check { display: flex; align-items: center; gap: 4px; }
    .trust-consensus { font-size: 0.85rem; color: var(--text-2); padding: 8px 0; border-top: 1px solid var(--border); margin-top: 8px; }
    .trust-warning { background: var(--warning-bg); color: var(--warning); padding: 8px 12px; border-radius: 4px; font-size: 0.8rem; margin-top: 8px; }
    .mode-toggle { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 6px; }
    .mode-toggle input { width: 18px; height: 18px; }
    .mode-toggle label { font-size: 0.875rem; color: var(--text-2); cursor: pointer; }
    .mode-toggle .hint { font-size: 0.8rem; color: var(--text-3); margin-left: auto; }
    footer { text-align: center; color: var(--text-3); font-size: 0.8rem; margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border); }
    footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <h1>Envelope Generator</h1>
  <p class="subtitle">Create Merkle envelopes for BSV transactions. <a href="https://github.com/speight-wq/merkle-envelope-tools" target="_blank" rel="noopener">GitHub</a></p>

  <div class="notice">
    <div class="notice-title">Requires Network</div>
    <div class="notice-text">This tool fetches data from the WhatsOnChain API. Transfer envelopes to your offline machine via USB.</div>
  </div>

  <div class="section">
    <!-- Multi-source toggle hidden until additional APIs available -->
    <div class="mode-toggle hidden">
      <input type="checkbox" id="multi-source-mode" checked>
      <label for="multi-source-mode">Multi-source verification</label>
      <span class="hint">Cross-validate with multiple APIs</span>
    </div>

    <div class="tabs">
      <button class="tab active" data-tab="txid">By TXID</button>
      <button class="tab" data-tab="address">By Address</button>
    </div>

    <div id="tab-txid" class="tab-content active">
      <div class="field">
        <label class="label">Transaction ID</label>
        <input type="text" class="input" id="txid-input" placeholder="Enter 64-character TXID">
        <div class="hint">Creates envelope for a specific transaction output</div>
      </div>
      <div class="field">
        <label class="label">Output Index (vout)</label>
        <input type="number" class="input input-narrow" id="vout-input" value="0" min="0">
      </div>
      <button class="btn btn-primary" id="fetch-txid-btn">Generate Envelope</button>
    </div>

    <div id="tab-address" class="tab-content">
      <div class="field">
        <label class="label">BSV Address</label>
        <input type="text" class="input" id="address-input" placeholder="1...">
        <div class="hint">P2PKH addresses only (starting with 1)</div>
      </div>
      <button class="btn btn-primary" id="fetch-address-btn">Fetch UTXOs</button>
    </div>

    <div id="progress-section" class="hidden">
      <div class="divider"></div>
      <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
      <div class="progress-text" id="progress-text">Fetching...</div>
    </div>

    <div id="trust-section" class="trust-summary hidden">
      <div class="trust-header">Source Verification</div>
      <div class="trust-sources" id="trust-sources"></div>
      <div class="trust-checks" id="trust-checks"></div>
      <div class="trust-consensus" id="trust-consensus"></div>
      <div id="trust-warning" class="trust-warning hidden"></div>
    </div>

    <div id="error-section" class="error-box hidden"></div>
  </div>

  <div id="results-section" class="section hidden">
    <div class="section-title">Generated Envelopes</div>
    <div id="envelope-list"></div>
    <div class="divider"></div>
    <div class="info-row"><span class="info-label">Total Value</span><span class="info-value" id="total-value"></span></div>
    <div class="info-row"><span class="info-label">Envelopes</span><span class="info-value" id="envelope-count"></span></div>
    <div class="btn-row">
      <button class="btn btn-primary" id="download-all-btn">Download All</button>
      <button class="btn btn-secondary" id="copy-all-btn">Copy to Clipboard</button>
    </div>
  </div>

  <footer>
    <a href="signer.html">Signer</a> · Generator · <a href="verifier.html">Verifier</a> · <a href="tests.html">Tests</a>
  </footer>

  <script>
  (function() {
    'use strict';

    // ==========================================
    // Multi-Source API Configuration
    // ==========================================
    // Note: GorillaPool does not provide WoC-compatible REST API for tx lookup
    // They use JungleBus (subscription) and ARC (broadcast) instead
    // For multi-source, we use WhatsOnChain as primary with single-source fallback
    // until additional compatible APIs become available
    
    const API_SOURCES = {
      whatsonchain: {
        name: 'WhatsOnChain',
        baseUrl: 'https://api.whatsonchain.com/v1/bsv/main',
        timeout: 15000,
        endpoints: {
          rawTx: (txid) => `/tx/${txid}/hex`,
          txInfo: (txid) => `/tx/hash/${txid}`,
          merkleProof: (txid) => `/tx/${txid}/proof/tsc`,
          merkleProofLegacy: (txid) => `/tx/${txid}/proof`,
          blockHeader: (hash) => `/block/${hash}/header`,
          utxos: (addr) => `/address/${addr}/unspent`
        }
      }
      // GorillaPool removed - does not support tx lookup via REST API
      // TAAL requires API key for most endpoints
      // Future: Add additional sources when compatible APIs become available
    };

    const ENABLED_SOURCES = ['whatsonchain'];
    const MIN_CONSENSUS = 1; // Single source until additional APIs available
    const API_BASE = API_SOURCES.whatsonchain.baseUrl;

    let envelopes = [];

    // ==========================================
    // Tab Switching
    // ==========================================
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
      });
    });

    // ==========================================
    // API Helpers
    // ==========================================
    async function fetchWithTimeout(url, timeout) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      try {
        const res = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        return res;
      } catch (e) {
        clearTimeout(timeoutId);
        throw e;
      }
    }

    async function fetchJson(url, timeout = 15000) {
      const res = await fetchWithTimeout(url, timeout);
      if (!res.ok) {
        if (res.status === 404) return null;
        throw new Error('HTTP ' + res.status);
      }
      return res.json();
    }

    async function fetchText(url, timeout = 15000) {
      const res = await fetchWithTimeout(url, timeout);
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return res.text();
    }

    function showProgress(pct, text) {
      document.getElementById('progress-section').classList.remove('hidden');
      document.getElementById('progress-fill').style.width = pct + '%';
      document.getElementById('progress-text').textContent = text;
    }

    function hideProgress() {
      document.getElementById('progress-section').classList.add('hidden');
    }

    function showError(msg) {
      const el = document.getElementById('error-section');
      el.textContent = msg;
      el.classList.remove('hidden');
    }

    function hideError() {
      document.getElementById('error-section').classList.add('hidden');
    }

    function hideTrustSummary() {
      document.getElementById('trust-section').classList.add('hidden');
    }

    function showTrustSummary(result) {
      const section = document.getElementById('trust-section');
      const sourcesDiv = document.getElementById('trust-sources');
      const checksDiv = document.getElementById('trust-checks');
      const consensusDiv = document.getElementById('trust-consensus');
      const warningDiv = document.getElementById('trust-warning');

      // Source status
      sourcesDiv.innerHTML = result.sources.map(s => {
        let statusClass = s.success ? 'source-ok' : 'source-fail';
        let statusIcon = s.success ? '✓' : '✗';
        let errorText = s.error ? ` (${s.error})` : '';
        return `<span class="source-status ${statusClass}">
          ${statusIcon} ${s.name}${errorText}
        </span>`;
      }).join('');

      // Check results
      if (result.checks) {
        checksDiv.innerHTML = `
          <span class="trust-check ${result.checks.rawTx ? 'source-ok' : 'source-fail'}">
            ${result.checks.rawTx ? '✓' : '✗'} rawTx
          </span>
          <span class="trust-check ${result.checks.blockHeader ? 'source-ok' : 'source-fail'}">
            ${result.checks.blockHeader ? '✓' : '✗'} blockHeader
          </span>
          <span class="trust-check ${result.checks.merkleProof ? 'source-ok' : 'source-fail'}">
            ${result.checks.merkleProof ? '✓' : '✗'} merkleProof
          </span>
        `;
      }

      // Consensus
      const agreed = result.sources.filter(s => s.success && s.agreed).length;
      const total = result.sources.length;
      
      if (result.singleSource) {
        consensusDiv.textContent = `Single source mode: ${agreed}/${total} sources available`;
        consensusDiv.style.color = 'var(--warning)';
      } else {
        consensusDiv.textContent = `Consensus: ${agreed}/${total} sources agree`;
        consensusDiv.style.color = agreed === total ? 'var(--success)' : 'var(--text-2)';
      }

      // Warning
      if (result.warning) {
        warningDiv.textContent = '⚠ ' + result.warning;
        warningDiv.classList.remove('hidden');
      } else {
        warningDiv.classList.add('hidden');
      }

      section.classList.remove('hidden');
    }

    // ==========================================
    // Multi-Source Data Fetching
    // ==========================================
    async function fetchFromSource(sourceId, txid) {
      const source = API_SOURCES[sourceId];
      const result = {
        sourceId,
        name: source.name,
        success: false,
        data: {},
        error: null
      };

      try {
        // Fetch raw tx
        const rawTx = await fetchText(
          source.baseUrl + source.endpoints.rawTx(txid),
          source.timeout
        );
        if (!rawTx) throw new Error('Transaction not found');
        result.data.rawTx = rawTx.toLowerCase().trim();

        // Fetch tx info
        const txInfo = await fetchJson(
          source.baseUrl + source.endpoints.txInfo(txid),
          source.timeout
        );
        if (!txInfo) throw new Error('TX info not found');
        result.data.txInfo = txInfo;

        // Fetch merkle proof if confirmed
        if (txInfo.blockhash) {
          result.data.blockhash = txInfo.blockhash;

          // Try TSC format first
          let proofData = null;
          try {
            const proof = await fetchJson(
              source.baseUrl + source.endpoints.merkleProof(txid),
              source.timeout
            );
            if (proof && Array.isArray(proof) && proof.length > 0) {
              proofData = proof[0];
            }
          } catch (e) {
            // Try legacy format
            const proof = await fetchJson(
              source.baseUrl + source.endpoints.merkleProofLegacy(txid),
              source.timeout
            );
            if (proof && proof.length > 0) {
              proofData = proof[0];
            }
          }

          if (proofData) {
            result.data.proofData = proofData;
            const proofNodes = proofData.nodes || proofData.siblings || [];
            result.data.proofNodes = proofNodes;
            result.data.txIndex = proofData.index || 0;
          }

          // Fetch block header
          const headerInfo = await fetchJson(
            source.baseUrl + source.endpoints.blockHeader(txInfo.blockhash),
            source.timeout
          );
          if (headerInfo) {
            // Build raw header from JSON
            const version = headerInfo.version.toString(16).padStart(8, '0');
            const versionLE = version.match(/../g).reverse().join('');
            const prevBlock = headerInfo.previousblockhash.match(/../g).reverse().join('');
            const merkleRoot = headerInfo.merkleroot.match(/../g).reverse().join('');
            const time = headerInfo.time.toString(16).padStart(8, '0');
            const timeLE = time.match(/../g).reverse().join('');
            const bits = headerInfo.bits;
            const bitsLE = bits.match(/../g).reverse().join('');
            const nonce = headerInfo.nonce.toString(16).padStart(8, '0');
            const nonceLE = nonce.match(/../g).reverse().join('');
            result.data.blockHeader = (versionLE + prevBlock + merkleRoot + timeLE + bitsLE + nonceLE).toLowerCase();
          }
        }

        result.success = true;
      } catch (e) {
        result.error = e.message;
      }

      return result;
    }

    // ==========================================
    // Multi-Source Consensus Validation
    // ==========================================
    function validateConsensus(responses, txid) {
      const successful = responses.filter(r => r.success);
      const failed = responses.filter(r => !r.success);
      
      // Check if failures are just 404s (transaction not indexed by that source)
      const hardFailures = failed.filter(r => r.error && !r.error.includes('404') && !r.error.includes('not found'));
      const softFailures = failed.filter(r => r.error && (r.error.includes('404') || r.error.includes('not found')));
      
      // If we have at least 1 successful source and others are just 404s, proceed with warning
      if (successful.length === 1 && softFailures.length > 0 && hardFailures.length === 0) {
        console.log('Single source available, others returned 404 - proceeding with warning');
        return {
          valid: true,
          data: successful[0].data,
          sources: responses.map(r => ({ 
            name: r.name, 
            success: r.success, 
            agreed: r.success,
            error: r.error
          })),
          checks: { rawTx: true, blockHeader: true, merkleProof: true },
          warning: `Only ${successful[0].name} has this transaction indexed. Cross-validation not possible.`,
          singleSource: true
        };
      }
      
      if (successful.length < MIN_CONSENSUS && hardFailures.length > 0) {
        return {
          valid: false,
          error: `Insufficient sources: ${successful.length}/${MIN_CONSENSUS} required. Errors: ${failed.map(f => f.name + ': ' + f.error).join(', ')}`,
          sources: responses.map(r => ({ 
            name: r.name, 
            success: r.success, 
            agreed: false,
            error: r.error 
          }))
        };
      }
      
      if (successful.length === 0) {
        return {
          valid: false,
          error: `No sources responded successfully`,
          sources: responses.map(r => ({ 
            name: r.name, 
            success: r.success, 
            agreed: false,
            error: r.error 
          }))
        };
      }

      // If only one source succeeded, use it with warning
      if (successful.length === 1) {
        return {
          valid: true,
          data: successful[0].data,
          sources: responses.map(r => ({ 
            name: r.name, 
            success: r.success, 
            agreed: r.success,
            error: r.error
          })),
          checks: { rawTx: true, blockHeader: true, merkleProof: true },
          warning: `Only ${successful[0].name} responded. Cross-validation not possible.`,
          singleSource: true
        };
      }

      // Compare rawTx byte-for-byte
      const rawTxes = successful.map(r => r.data.rawTx);
      const rawTxMatch = rawTxes.every(tx => constantTimeEqual(tx, rawTxes[0]));
      if (!rawTxMatch) {
        return {
          valid: false,
          error: 'CRITICAL: rawTx mismatch between sources — possible attack',
          sources: responses.map(r => ({ name: r.name, success: r.success, agreed: false })),
          checks: { rawTx: false, blockHeader: false, merkleProof: false }
        };
      }

      // Verify TXID matches rawTx
      const computedTxid = reverseHex(bytesToHex(hash256(rawTxes[0])));
      if (!constantTimeEqual(computedTxid.toLowerCase(), txid.toLowerCase())) {
        return {
          valid: false,
          error: 'TXID does not match rawTx hash',
          sources: responses.map(r => ({ name: r.name, success: r.success, agreed: false })),
          checks: { rawTx: false, blockHeader: false, merkleProof: false }
        };
      }

      // Compare blockHeader byte-for-byte (if confirmed)
      const withHeaders = successful.filter(r => r.data.blockHeader);
      let headerMatch = true;
      if (withHeaders.length >= 2) {
        const headers = withHeaders.map(r => r.data.blockHeader);
        headerMatch = headers.every(h => constantTimeEqual(h, headers[0]));
        if (!headerMatch) {
          return {
            valid: false,
            error: 'CRITICAL: blockHeader mismatch between sources — possible chain split',
            sources: responses.map(r => ({ name: r.name, success: r.success, agreed: false })),
            checks: { rawTx: true, blockHeader: false, merkleProof: false }
          };
        }
      }

      // Verify Merkle proofs independently
      let merkleMatch = true;
      const withProofs = successful.filter(r => r.data.proofNodes && r.data.blockHeader);
      if (withProofs.length >= 2) {
        const computedRoots = withProofs.map(r => {
          try {
            const proofArray = r.data.proofNodes.map((node, i) => ({
              hash: node === '*' ? '*' : reverseHex(node),
              pos: ((r.data.txIndex >> i) & 1) ? 'L' : 'R'
            }));
            const header = parseHeader(r.data.blockHeader);
            const valid = verifyMerkleProof(txid, proofArray, header.merkleRoot);
            return { source: r.name, valid, root: header.merkleRoot };
          } catch (e) {
            return { source: r.name, valid: false, error: e.message };
          }
        });

        merkleMatch = computedRoots.every(r => r.valid);
        if (!merkleMatch) {
          return {
            valid: false,
            error: 'Merkle proof verification failed',
            sources: responses.map(r => ({ name: r.name, success: r.success, agreed: false })),
            checks: { rawTx: true, blockHeader: true, merkleProof: false }
          };
        }
      }

      // All checks passed
      return {
        valid: true,
        data: successful[0].data,
        sources: responses.map(r => ({ 
          name: r.name, 
          success: r.success, 
          agreed: r.success,
          error: r.error
        })),
        checks: { rawTx: true, blockHeader: headerMatch, merkleProof: merkleMatch },
        warning: successful.length < responses.length ? 
          `${successful.length}/${responses.length} sources verified` : null
      };
    }

    // ==========================================
    // Generate Envelope (Multi-Source)
    // ==========================================
    async function generateEnvelopeMultiSource(txid, vout) {
      showProgress(10, 'Fetching from multiple sources...');

      // Fetch from all sources in parallel
      const fetchPromises = ENABLED_SOURCES.map(sourceId => 
        fetchFromSource(sourceId, txid)
      );
      
      const responses = await Promise.all(fetchPromises);
      showProgress(60, 'Validating consensus...');

      // Validate consensus
      const consensus = validateConsensus(responses, txid);
      
      if (!consensus.valid) {
        return { success: false, error: consensus.error, consensus };
      }

      showProgress(80, 'Building envelope...');

      // Build envelope from validated data
      const data = consensus.data;
      const txInfo = data.txInfo;
      
      if (vout >= txInfo.vout.length) {
        return { success: false, error: 'vout out of range', consensus };
      }

      const output = txInfo.vout[vout];
      const satoshis = Math.round(output.value * 1e8);

      const envelope = {
        format: 'merkle-envelope',
        version: 1,
        txid: txid,
        vout: vout,
        satoshis: satoshis,
        rawTx: data.rawTx,
        confirmations: txInfo.confirmations || 0
      };

      // Add proof data if available
      if (data.blockHeader && data.proofNodes && data.proofNodes.length > 0) {
        const header = parseHeader(data.blockHeader);
        const proofArray = data.proofNodes.map((node, i) => ({
          hash: node === '*' ? '*' : reverseHex(node),
          pos: ((data.txIndex >> i) & 1) ? 'L' : 'R'
        }));

        // Final verification
        const valid = verifyMerkleProof(txid, proofArray, header.merkleRoot);
        if (valid) {
          envelope.blockHeader = data.blockHeader;
          envelope.blockHash = data.blockhash;
          envelope.proof = proofArray;
        }
      }

      showProgress(100, 'Complete');
      return { success: true, envelope, consensus };
    }

    // ==========================================
    // Generate Envelope (Single Source - Legacy)
    // ==========================================
    async function generateEnvelopeForTxid(txid, vout) {
      // Fetch raw tx
      const rawTx = await fetchText(API_BASE + '/tx/' + txid + '/hex');
      if (!rawTx) throw new Error('Transaction not found');

      // Verify txid
      const computedTxid = reverseHex(bytesToHex(hash256(rawTx)));
      if (computedTxid.toLowerCase() !== txid.toLowerCase()) {
        throw new Error('TXID mismatch');
      }

      // Fetch tx info
      const txInfo = await fetchJson(API_BASE + '/tx/hash/' + txid);
      if (!txInfo) throw new Error('TX info not found');

      if (vout >= txInfo.vout.length) throw new Error('vout out of range');
      const output = txInfo.vout[vout];
      const satoshis = Math.round(output.value * 1e8);

      // Fetch merkle proof if confirmed
      let envelope = {
        format: 'merkle-envelope',
        version: 1,
        txid: txid,
        vout: vout,
        satoshis: satoshis,
        rawTx: rawTx,
        confirmations: txInfo.confirmations || 0
      };

      if (txInfo.blockhash) {
        // Fetch merkle proof - try TSC format first, then legacy
        try {
          let proofData = null;
          
          // Try TSC format endpoint
          let proof = await fetchJson(API_BASE + '/tx/' + txid + '/proof/tsc');
          console.log('TSC Proof response:', proof);
          
          if (proof && Array.isArray(proof) && proof.length > 0) {
            // TSC format returns array, first element has the proof
            proofData = proof[0];
            console.log('TSC proof data:', proofData);
          }
          
          if (!proofData) {
            // Try legacy format
            proof = await fetchJson(API_BASE + '/tx/' + txid + '/proof');
            console.log('Legacy Proof response:', proof);
            if (proof && proof.length > 0) {
              proofData = proof[0];
            }
          }
          
          // TSC format uses 'siblings' not 'nodes'
          const proofNodes = proofData ? (proofData.nodes || proofData.siblings || []) : [];
          const txIndex = proofData ? proofData.index : 0;
          
          if (proofNodes.length > 0) {
            console.log('Proof nodes:', proofNodes.length, 'index:', txIndex);

            // Fetch block header (returns JSON, not raw hex)
            const headerInfo = await fetchJson(API_BASE + '/block/' + txInfo.blockhash + '/header');
            console.log('Header info:', headerInfo);
            
            // Build raw header from JSON fields (80 bytes = 160 hex chars)
            const version = headerInfo.version.toString(16).padStart(8, '0');
            const versionLE = version.match(/../g).reverse().join('');
            const prevBlock = headerInfo.previousblockhash.match(/../g).reverse().join('');
            const merkleRoot = headerInfo.merkleroot.match(/../g).reverse().join('');
            const time = headerInfo.time.toString(16).padStart(8, '0');
            const timeLE = time.match(/../g).reverse().join('');
            const bits = headerInfo.bits;
            const bitsLE = bits.match(/../g).reverse().join('');
            const nonce = headerInfo.nonce.toString(16).padStart(8, '0');
            const nonceLE = nonce.match(/../g).reverse().join('');
            const blockHeader = versionLE + prevBlock + merkleRoot + timeLE + bitsLE + nonceLE;
            console.log('Built header:', blockHeader.length, 'chars');

            // Verify merkle proof
            const header = parseHeader(blockHeader);

            // Build proof array for envelope - handle both '*' wildcards and actual hashes
            const proofArray = proofNodes.map((node, i) => {
              // TSC format uses '*' for positions that should use the computed hash
              const isWildcard = node === '*';
              return {
                hash: isWildcard ? '*' : reverseHex(node),
                pos: ((txIndex >> i) & 1) ? 'L' : 'R'
              };
            });

            // Verify
            const valid = verifyMerkleProof(txid, proofArray, header.merkleRoot);
            console.log('Merkle proof valid:', valid);

            if (valid) {
              envelope.blockHeader = blockHeader;
              envelope.blockHash = txInfo.blockhash;
              envelope.proof = proofArray;
            }
          } else {
            console.log('No proof nodes available for', txid);
          }
        } catch (proofErr) {
          console.error('Failed to get proof:', proofErr);
        }
      }

      return envelope;
    }

    // ==========================================
    // Fetch by TXID
    // ==========================================
    document.getElementById('fetch-txid-btn').addEventListener('click', async function() {
      const txid = document.getElementById('txid-input').value.trim();
      const vout = parseInt(document.getElementById('vout-input').value) || 0;
      const multiSourceEnabled = document.getElementById('multi-source-mode').checked;

      if (!txid || txid.length !== 64) {
        showError('Enter a valid 64-character TXID');
        return;
      }

      hideError();
      hideTrustSummary();
      envelopes = [];

      try {
        if (multiSourceEnabled) {
          // Multi-source mode
          const result = await generateEnvelopeMultiSource(txid, vout);
          
          if (!result.success) {
            showError(result.error);
            if (result.consensus) {
              showTrustSummary(result.consensus);
            }
            hideProgress();
            return;
          }
          
          showTrustSummary(result.consensus);
          envelopes = [result.envelope];
        } else {
          // Single source mode (legacy)
          showProgress(20, 'Fetching from WhatsOnChain...');
          const envelope = await generateEnvelopeForTxid(txid, vout);
          showProgress(100, 'Done');
          envelopes = [envelope];
        }

        displayEnvelopes();

      } catch (err) {
        showError(err.message);
      } finally {
        hideProgress();
      }
    });

    // ==========================================
    // Fetch by Address
    // ==========================================
    document.getElementById('fetch-address-btn').addEventListener('click', async function() {
      const address = document.getElementById('address-input').value.trim();
      const multiSourceEnabled = document.getElementById('multi-source-mode').checked;

      if (!address) {
        showError('Enter an address');
        return;
      }

      // P2PKH only - addresses starting with 1
      if (!address.startsWith('1')) {
        showError('Only P2PKH addresses (starting with 1) are supported. P2SH addresses (starting with 3) are not supported.');
        return;
      }

      hideError();
      hideTrustSummary();
      envelopes = [];

      try {
        showProgress(10, 'Fetching UTXOs...');

        // Fetch UTXOs (always from primary source for address lookup)
        const primarySource = API_SOURCES[ENABLED_SOURCES[0]];
        const utxos = await fetchJson(
          primarySource.baseUrl + primarySource.endpoints.utxos(address),
          primarySource.timeout
        );
        
        if (!utxos || utxos.length === 0) {
          showError('No UTXOs found for this address');
          hideProgress();
          return;
        }

        showProgress(20, 'Found ' + utxos.length + ' UTXOs. Generating envelopes...');

        let lastConsensus = null;
        for (let i = 0; i < utxos.length; i++) {
          const utxo = utxos[i];
          const pct = 20 + (80 * (i + 1) / utxos.length);
          showProgress(pct, 'Processing ' + (i + 1) + ' / ' + utxos.length);

          try {
            if (multiSourceEnabled) {
              const result = await generateEnvelopeMultiSource(utxo.tx_hash, utxo.tx_pos);
              if (result.success) {
                envelopes.push(result.envelope);
                lastConsensus = result.consensus;
              }
            } else {
              const envelope = await generateEnvelopeForTxid(utxo.tx_hash, utxo.tx_pos);
              envelopes.push(envelope);
            }
          } catch (err) {
            console.error('Failed to generate envelope for', utxo.tx_hash, err);
          }

          // Rate limiting
          await new Promise(r => setTimeout(r, multiSourceEnabled ? 500 : 200));
        }

        if (multiSourceEnabled && lastConsensus) {
          showTrustSummary(lastConsensus);
        }

        displayEnvelopes();

      } catch (err) {
        showError(err.message);
      } finally {
        hideProgress();
      }
    });

    // ==========================================
    // Display Envelopes
    // ==========================================
    function displayEnvelopes() {
      if (envelopes.length === 0) {
        document.getElementById('results-section').classList.add('hidden');
        return;
      }

      const listDiv = document.getElementById('envelope-list');
      let html = '';
      let total = 0;

      for (const env of envelopes) {
        total += env.satoshis;
        const status = env.proof ? '✓ Merkle proof' : (env.confirmations > 0 ? '! No proof' : '⚠ Unconfirmed');
        const statusColor = env.proof ? 'var(--success)' : 'var(--warning)';

        html += '<div class="envelope-item">' +
          '<div class="envelope-header">' +
          '<span class="envelope-txid">' + env.txid.slice(0, 16) + '...:' + env.vout + '</span>' +
          '<span class="envelope-amount">' + (env.satoshis / 1e8).toFixed(8) + ' BSV</span>' +
          '</div>' +
          '<div style="font-size: 0.8rem; color: ' + statusColor + ';">' + status + '</div>' +
          '</div>';
      }

      listDiv.innerHTML = html;
      document.getElementById('total-value').textContent = (total / 1e8).toFixed(8) + ' BSV';
      document.getElementById('envelope-count').textContent = envelopes.length;
      document.getElementById('results-section').classList.remove('hidden');
    }

    // ==========================================
    // Download / Copy
    // ==========================================
    document.getElementById('download-all-btn').addEventListener('click', function() {
      const data = envelopes.length === 1 ? envelopes[0] : envelopes;
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'envelopes-' + Date.now() + '.json';
      a.click();
    });

    document.getElementById('copy-all-btn').addEventListener('click', function() {
      const data = envelopes.length === 1 ? envelopes[0] : envelopes;
      navigator.clipboard.writeText(JSON.stringify(data, null, 2)).then(() => {
        this.textContent = '✓ Copied!';
        setTimeout(() => this.textContent = 'Copy to Clipboard', 2000);
      });
    });

  })();
  </script>
</body>
</html>
